const FunctionBuilder = class FunctionBuilder {
    /**
     * fx should be a function with a range of 0..1, and a period of 1.
     * Otherwise, make sure to specify the old range or frequency/period when calling those functions.
     */
    constructor(fx) {
        this.rootfx = fx;
        this.A = 1;
        this.B = 1;
        this.C = 0;
        this.D = 0;
    }

    frequencyMod(x) {
        return identityFrequencyMod(x);
    }

    phaseMod(x) {
        return identityPhaseMod(x);
    }

    /**
     * Get a function of the form (x => y) that represents the output of this FunctionBuilder.
     */
    getFx() {
        const B2 = x => this.B * this.frequencyMod(x);
        const C2 = x => this.C + this.phaseMod(x); 
        const fx = x => {
            const a = this.A;
            const b = B2(x);
            const c = C2(x);
            const d = this.D;
            const func = this.rootfx;
            return a * func(b * (x + c)) + d;
            //note the form: b * (x + c), instead of: b * x + c
            //normally c = (-phaseShift * b), but we're intentionally factoring out the b.
            //This is so we can wait until generating fx to combine b and c, so they can be
            //changed arbitrarily. so therefore it became bx + bc, which factors to: b(x + c).
        };
        return fx;
    }

    static Build(config) {
        const frequency = config.frequency || 1;
        const rangeMin = config.rangeMin || 0;
        const rangeMax = config.rangeMax || 1;
        const phaseShift = config.phaseShift || 0;
        const fMod = config.frequencyModulator || identityFrequencyMod;
        const phaseMod = config.phaseModulator || identityPhaseMod;
        
    }
    
    /**
     * Specify the desired range of output values generated by this function.
     * If the fx this function started with is not already in range 0..1,
     * then specify its range with oldMin and oldMax.
     * For example, if fx was a Sine function from -1 to +1, and
     * you wanted the output to be from 0-360, you would call:
     * sine.setRange(0, 360, -1, 1);
     * Returns FunctionBuilder instance.
     */
    setRange(newMin, newMax, oldMin = 0, oldMax = 1) {
        const newRangeDifference = newMax - newMin;
        const oldRangeDifference = oldMax - oldMin;
        let a = 0;
        if(oldRangeDifference != 0) {
            a = newRangeDifference / oldRangeDifference;
        }
        this.A = a;
        this.D = newMin - (a * oldMin);
        return copy(this);
    }

    /**
     * Specify the range of the fx this function was created with, if it was not 0..1
     * The output range of this function will be set to 0..1.
     * This is the same as calling: setRange(0, 1, min, max);
     * For example, if you called: new FunctionBuilder(x => Math.sin(x*2*PI)).ofRange(-1, 1).getFx()
     * you would get a sine function with range 0..1
     * Returns FunctionBuilder instance.
     */
    ofRange(min, max) {
        const rangeDifference = max - min;
        let a = 0;
        if(rangeDifference != 0) {
            a = 1 / rangeDifference;
        }
        this.A = a;
        this.D = 0 - (a * min);
        return copy(this);
    }

    /**
     * Sets the amount by which the function will be shifted along the x-axis (phase shift).
     * Passing a shiftPeriod of 1 would shift the function by one full period.
     * For a cyclic function, this would be the same as passing 0, or not shifting at all.
     * Returns FunctionBuilder instance.
     */
    setPhaseShift(shiftPeriod) {
        this.C = -shiftPeriod;
        return copy(this);
    }

    /**
     * Set the frequency of this function, ie periods/cycles per domain 0..1. If the input fx
     * is not frequency 1, then you must specify oldFrequency for the output to be correct.
     * Frequency and period are inverse representations of the same property. So the following
     * functions all overwrite each other: ofFrequency, setFrequency, ofPeriod, setPeriod.
     * Returns FunctionBuilder instance.
     */
    setFrequency(frequency, oldFrequency = 1) {
        if(oldFrequency == 0) {
            this.B = 0;
            return copy(this);
        }
        this.B = frequency / oldFrequency;
        return copy(this);
    }

    /**
     * Set the period of this function -- (. If the input fx is not period 1, then you
     * must specify oldPeriod for the output to be correct. Frequency and period are
     * inverse representations of the same property. So the following functions all
     * overwrite each other: ofFrequency, setFrequency, ofPeriod, setPeriod.
     * Returns FunctionBuilder instance.
     */
    setPeriod(period, oldPeriod = 1) {
        this.B = oldPeriod * period;
        return copy(this);
    }

    /**
     * Specify the frequency of the fx this function was created with, if it was not 1.
     * The output frequency of this function will be set to 1.
     * This is the same as calling: setFrequency(1, frequencyHz);
     * For example, if you called: new FunctionBuilder(Math.sin).ofFrequency(1/(2*PI)).getFx()
     * you would get a sine function with frequency 1.
     * Frequency and period are inverse representations of the same property. So the following
     * functions all overwrite each other: ofFrequency, setFrequency, ofPeriod, setPeriod.
     * Returns FunctionBuilder instance.
     */
    ofFrequency(frequencyHz) {
        if(frequencyHz == 0) {
            this.B = 0;
            return copy(this);
        }
        this.B = 1 / frequencyHz;
        return copy(this);
    }

    /**
     * Specify the period of the fx this function was created with, if it was not 1.
     * The output period of this function will be set to 1.
     * This is the same as calling: setPeriod(1000, periodMs);
     * For example, if you called: new FunctionBuilder(Math.sin).ofPeriod(2*PI).getFx()
     * you would get a sine function with period 1.
     * Frequency and period are inverse representations of the same property. So the following
     * functions all overwrite each other: ofFrequency, setFrequency, ofPeriod, setPeriod.
     * Returns FunctionBuilder instance.
     */
    ofPeriod(periodMs) {
        this.B = periodMs;
        return copy(this);
    }

    /**
     * The frequency of this function will be changed by the values of modulatorFx.
     * applyFrequencyModulation applies another round of modulation, and can be called successively.
     * (modulatorFx will be called with values 0..1)
     * If modulatorFx(x) = m, then this function's f(x) will become f(mx).
     * Because this value is multiplicative, modulatorFx will increase the frequency of this function
     * with values > 1, and reduce the frequency with values between 0 and 1.
     * This method can be used in addition to setting the period/frequency outright.
     * Returns FunctionBuilder instance.
     */
    applyFrequencyModulation(modulatorFx) {
        const carrier = this.frequencyMod;
        this.frequencyMod = x => carrier(x) * modulatorFx(x);
        return copy(this);
    }

    /**
     * The frequency of this function will be changed by the values of modulatorFx.
     * setFrequencyModulation sets a new function to be used for this, overwriting any previous frequency modulation.
     * (modulatorFx will be called with values 0..1)
     * If m = modulatorFx(x), then this function's f(x) will become f(m*x).
     * Because this value is multiplicative, modulatorFx will increase the frequency of this function
     * with values > 1, and reduce the frequency with values between 0 and 1.
     * This method can be used in addition to setting the period/frequency outright.
     * Returns FunctionBuilder instance.
     */
    setFrequencyModulation(modulatorFx) {
        this.frequencyMod = modulatorFx;
        return copy(this);
    }

    /**
     * The phase shift of this function will be changed by the values of modulatorFx.
     * applyPhaseShiftModulation applies another round of modulation, and can be called successively.
     * (modulatorFx will be called with values 0..1)
     * If modulatorFx(x) = m, then this function's f(x) will become f(mx).
     * Because this value is additive, modulatorFx will shift this function to the right with positive values,
     * and to the left with negative ones.
     * This method can be used in addition to setting the phase shift outright.
     * Returns FunctionBuilder instance.
     */
    applyPhaseShiftModulation(modulatorFx) {
        const carrier = this.phaseMod;
        this.phaseMod = x => carrier(x) + modulatorFx(x);
        return copy(this);
    }

    /**
     * The phase shift of this function will be changed by the values of modulatorFx.
     * setPhaseShiftModulation sets a new function to be used for this, overwriting any previous phase shift modulation.
     * (modulatorFx will be called with values 0..1)
     * If m = modulatorFx(x), then this function's f(x) will become f(m*x).
     * Because this value is additive, modulatorFx will shift this function to the right with positive values,
     * and to the left with negative ones.
     * This method can be used in addition to setting the phase shift outright.
     * Returns FunctionBuilder instance.
     */
    setPhaseShiftModulation(modulatorFx) {
        this.phaseMod = modulatorFx;
        return copy(this);
    }
};

function copy(builder) {
    const result = new FunctionBuilder(builder.rootfx);
    result.A = builder.A;
    result.B = builder.B;
    result.C = builder.C;
    result.D = builder.D;
    result.frequencyMod = builder.frequencyMod;
    result.phaseMod = builder.phaseMod;
    return result;
}

function identityFrequencyMod(x) {
    return 1;
}

function identityPhaseMod(x) {
    return 0;
}

export default FunctionBuilder;